/* 
* @FileName: lcd_12864.c
* @Author  : PeeNut
* @Date    : 2015-08-08 19:48:15
* @Description: lcd12864的驱动，使用6*8的英文字库，中文显示用过disp_chn函数支持，支持的是16*16字体
*               还包含把整形和浮点型数据按16进制或者10进制显示出来，浮点数显示可以指定小数位数
* @Modified by  |  Modified time  |  Description 
*  
*/

#include <math.h>
#include "../inc/lcd_12864.h"

#define nop() __no_operation();

const uchar adj_page[]={7,6,5,4,3,2,1,0};

//tab[16*64]/*--  宋体16*16;  此字体下对应的点阵为：宽x高=16x16   --*/
const uchar tab[]={
0x00,0x00,0xF8,0x88,0x88,0x88,0x88,0xFF,0x88,0x88,0x88,0x88,0xF8,0x00,0x00,0x00,
0x00,0x00,0x1F,0x08,0x08,0x08,0x08,0x7F,0x88,0x88,0x88,0x88,0x9F,0x80,0xF0,0x00,/*"电",0*/

0x00,0x04,0x04,0x04,0x04,0x04,0x04,0xFC,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x00,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3F,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,/*"工",1*/

0x00,0x04,0x04,0x04,0xFF,0x54,0x54,0x54,0x54,0x54,0xFF,0x04,0x04,0x04,0x00,0x00,
0x11,0x11,0x89,0x85,0x93,0x91,0x91,0xFD,0x91,0x91,0x93,0x85,0x89,0x11,0x11,0x00,/*"基",2*/

0x20,0x20,0x20,0xFF,0x20,0x20,0x80,0xF8,0x80,0x40,0xFF,0x20,0x10,0xF0,0x00,0x00,
0x10,0x30,0x10,0x0F,0x08,0x08,0x00,0x3F,0x40,0x40,0x5F,0x42,0x44,0x43,0x78,0x00,/*"地",3*/

0x10,0x60,0x02,0x8C,0x00,0x00,0xFE,0x92,0x92,0x92,0x92,0x92,0xFE,0x00,0x00,0x00,
0x04,0x04,0x7E,0x01,0x40,0x7E,0x42,0x42,0x7E,0x42,0x7E,0x42,0x42,0x7E,0x40,0x00,/*"温",4*/

0x00,0x00,0xFC,0x24,0x24,0x24,0xFC,0x25,0x26,0x24,0xFC,0x24,0x24,0x24,0x04,0x00,
0x40,0x30,0x8F,0x80,0x84,0x4C,0x55,0x25,0x25,0x25,0x55,0x4C,0x80,0x80,0x80,0x00,/*"度",5*/

0x06,0x09,0x09,0xE6,0xF8,0x0C,0x04,0x02,0x02,0x02,0x02,0x02,0x04,0x1E,0x00,0x00,
0x00,0x00,0x00,0x07,0x1F,0x30,0x20,0x40,0x40,0x40,0x40,0x40,0x20,0x10,0x00,0x00,/*"℃",6*/

0x04,0x04,0x04,0x84,0xE4,0x3C,0x27,0x24,0x24,0x24,0x24,0xE4,0x04,0x04,0x04,0x00,
0x04,0x02,0x01,0x00,0xFF,0x09,0x09,0x09,0x09,0x49,0x89,0x7F,0x00,0x00,0x00,0x00,/*"有",7*/

0x00,0x40,0x42,0x42,0x42,0xC2,0x7E,0x42,0xC2,0x42,0x42,0x42,0x40,0x40,0x00,0x00,
0x80,0x40,0x20,0x10,0x0C,0x03,0x00,0x00,0x3F,0x40,0x40,0x40,0x40,0x70,0x00,0x00,/*"无",8*/

0x40,0x40,0x42,0x44,0x58,0xC0,0x40,0x7F,0x40,0xC0,0x50,0x48,0x46,0x40,0x40,0x00,
0x80,0x80,0x40,0x20,0x18,0x07,0x00,0x00,0x00,0x3F,0x40,0x40,0x40,0x40,0x78,0x00,/*"光",9*/

0x00,0xFE,0x42,0x42,0x42,0xFE,0x00,0x42,0xA2,0x9E,0x82,0xA2,0xC2,0xBE,0x00,0x00,
0x80,0x6F,0x08,0x08,0x28,0xCF,0x00,0x00,0x2F,0xC8,0x08,0x08,0x28,0xCF,0x00,0x00,/*"照",10*/

0x00,0x80,0x8C,0x9C,0x18,0xC0,0x60,0x2E,0x2E,0x60,0xC0,0x18,0x9C,0x8C,0x80,0x00,
0x00,0x01,0x31,0x39,0x18,0x03,0x06,0x74,0x74,0x06,0x03,0x18,0x39,0x31,0x01,0x00,/*"日-icon",11*/
};

// Font lookup table
static const uint8_t FONT6x8[] = {
    /* 6x8 font, each line is a character each byte is a one pixel wide column
     * of that character. MSB is the top pixel of the column, LSB is the bottom
     * pixel of the column. 0 = pixel off. 1 = pixel on. */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // " "
	0x00, 0x00, 0x5f, 0x00, 0x00, 0x00,  // "!"
	0x00, 0x07, 0x00, 0x07, 0x00, 0x00,  // """
	0x14, 0x7f, 0x14, 0x7f, 0x14, 0x00,  // "#"
	0x24, 0x2a, 0x7f, 0x2a, 0x12, 0x00,  // "$"
	0x23, 0x13, 0x08, 0x64, 0x62, 0x00,  // "%"
	0x36, 0x49, 0x56, 0x20, 0x50, 0x00,  // "&"
	0x00, 0x08, 0x07, 0x03, 0x00, 0x00,  // "'"
	0x00, 0x1c, 0x22, 0x41, 0x00, 0x00,  // "("
	0x00, 0x41, 0x22, 0x1c, 0x00, 0x00,  // ")"
	0x2a, 0x1c, 0x7f, 0x1c, 0x2a, 0x00,  // "*"
	0x08, 0x08, 0x3e, 0x08, 0x08, 0x00,  // "+"
	0x00, 0x40, 0x38, 0x18, 0x00, 0x00,  // ","
	0x08, 0x08, 0x08, 0x08, 0x08, 0x00,  // "-"
	0x00, 0x00, 0x60, 0x60, 0x00, 0x00,  // "."
	0x20, 0x10, 0x08, 0x04, 0x02, 0x00,  // "/"
	//96 Bytes
	0x3e, 0x51, 0x49, 0x45, 0x3e, 0x00,  // "0"
	0x00, 0x42, 0x7f, 0x40, 0x00, 0x00,  // "1"
	0x42, 0x61, 0x51, 0x49, 0x46, 0x00,  // "2"
	0x21, 0x41, 0x49, 0x4d, 0x33, 0x00,  // "3"
	0x18, 0x14, 0x12, 0x7f, 0x10, 0x00,  // "4"
	0x27, 0x45, 0x45, 0x45, 0x39, 0x00,  // "5"
	0x3c, 0x4a, 0x49, 0x49, 0x30, 0x00,  // "6"
	0x41, 0x21, 0x11, 0x09, 0x07, 0x00,  // "7"
	0x36, 0x49, 0x49, 0x49, 0x36, 0x00,  // "8"
	0x06, 0x49, 0x49, 0x29, 0x1e, 0x00,  // "9"
	0x00, 0x00, 0x14, 0x00, 0x00, 0x00,  // ":"
	0x00, 0x00, 0x40, 0x34, 0x00, 0x00,  // ";"
	0x00, 0x08, 0x14, 0x22, 0x41, 0x00,  // "<"
	0x14, 0x14, 0x14, 0x14, 0x14, 0x00,  // "="
	0x00, 0x41, 0x22, 0x14, 0x08, 0x00,  // ">"
	0x02, 0x01, 0x51, 0x09, 0x06, 0x00,  // "?"
	//96*2 = 192 Bytes
	0x3e, 0x41, 0x5d, 0x59, 0x4e, 0x00,  // "@"
	0x7c, 0x12, 0x11, 0x12, 0x7c, 0x00,  // "A"
	0x7f, 0x49, 0x49, 0x49, 0x36, 0x00,  // "B"
	0x3e, 0x41, 0x41, 0x41, 0x22, 0x00,  // "C"
	0x7f, 0x41, 0x41, 0x41, 0x3e, 0x00,  // "D"
	0x7f, 0x49, 0x49, 0x49, 0x41, 0x00,  // "E"
	0x7f, 0x09, 0x09, 0x09, 0x01, 0x00,  // "F"
	0x3e, 0x41, 0x49, 0x49, 0x7a, 0x00,  // "G"
	0x7f, 0x08, 0x08, 0x08, 0x7f, 0x00,  // "H"
	0x00, 0x41, 0x7f, 0x41, 0x00, 0x00,  // "I"
	0x20, 0x40, 0x41, 0x3f, 0x01, 0x00,  // "J"
	0x7f, 0x08, 0x14, 0x22, 0x41, 0x00,  // "K"
	0x7f, 0x40, 0x40, 0x40, 0x40, 0x00,  // "L"
	0x7f, 0x02, 0x1c, 0x02, 0x7f, 0x00,  // "M"
	0x7f, 0x04, 0x08, 0x10, 0x7f, 0x00,  // "N"
	0x3e, 0x41, 0x41, 0x41, 0x3e, 0x00,  // "O"
	//96*3 = 288 Bytes
	0x7f, 0x09, 0x09, 0x09, 0x06, 0x00,  // "P"
	0x3e, 0x41, 0x51, 0x21, 0x5e, 0x00,  // "Q"
	0x7f, 0x09, 0x19, 0x29, 0x46, 0x00,  // "R"
	0x26, 0x49, 0x49, 0x49, 0x32, 0x00,  // "S"
	0x01, 0x01, 0x7f, 0x01, 0x01, 0x00,  // "T"
	0x3f, 0x40, 0x40, 0x40, 0x3f, 0x00,  // "U"
	0x1f, 0x20, 0x40, 0x20, 0x1f, 0x00,  // "V"
	0x3f, 0x40, 0x38, 0x40, 0x3f, 0x00,  // "W"
	0x63, 0x14, 0x08, 0x14, 0x63, 0x00,  // "X"
	0x03, 0x04, 0x78, 0x04, 0x03, 0x00,  // "Y"
	0x61, 0x51, 0x49, 0x45, 0x43, 0x00,  // "Z"
	0x00, 0x7f, 0x41, 0x41, 0x41, 0x00,  // "["
	0x02, 0x04, 0x08, 0x10, 0x20, 0x00,  // "\"
	0x00, 0x41, 0x41, 0x41, 0x7f, 0x00,  // "]"
	0x04, 0x02, 0x01, 0x02, 0x04, 0x00,  // "^"
	0x80, 0x80, 0x80, 0x80, 0x80, 0x00,  // "_"
	//96*4 = 384 Bytes
	0x00, 0x03, 0x07, 0x08, 0x00, 0x00,  // "`"
	0x20, 0x54, 0x54, 0x54, 0x78, 0x00,  // "a"
	0x7f, 0x28, 0x44, 0x44, 0x38, 0x00,  // "b"
	0x38, 0x44, 0x44, 0x44, 0x28, 0x00,  // "c"
	0x38, 0x44, 0x44, 0x28, 0x7f, 0x00,  // "d"
	0x38, 0x54, 0x54, 0x54, 0x18, 0x00,  // "e"
	0x00, 0x08, 0x7e, 0x09, 0x02, 0x00,  // "f"
	0x18, 0xa4, 0xa4, 0xa4, 0x7c, 0x00,  // "g"
	0x7f, 0x08, 0x04, 0x04, 0x78, 0x00,  // "h"
	0x00, 0x44, 0x7d, 0x40, 0x00, 0x00,  // "i"
	0x00, 0x20, 0x40, 0x40, 0x3d, 0x00,  // "j"
	0x00, 0x7f, 0x10, 0x28, 0x44, 0x00,  // "k"
	0x00, 0x41, 0x7f, 0x40, 0x00, 0x00,  // "l"
	0x7c, 0x04, 0x78, 0x04, 0x78, 0x00,  // "m"
	0x7c, 0x08, 0x04, 0x04, 0x78, 0x00,  // "n"
	0x38, 0x44, 0x44, 0x44, 0x38, 0x00,  // "o"
	//96*5 = 480 Bytes
	0xfc, 0x18, 0x24, 0x24, 0x18, 0x00,  // "p"
	0x18, 0x24, 0x24, 0x18, 0xfc, 0x00,  // "q"
	0x7c, 0x08, 0x04, 0x04, 0x08, 0x00,  // "r"
	0x48, 0x54, 0x54, 0x54, 0x24, 0x00,  // "s"
	0x04, 0x04, 0x3f, 0x44, 0x24, 0x00,  // "t"
	0x3c, 0x40, 0x40, 0x20, 0x7c, 0x00,  // "u"
	0x1c, 0x20, 0x40, 0x20, 0x1c, 0x00,  // "v"
	0x3c, 0x40, 0x30, 0x40, 0x3c, 0x00,  // "w"
	0x44, 0x28, 0x10, 0x28, 0x44, 0x00,  // "x"
	0x4c, 0x90, 0x90, 0x90, 0x7c, 0x00,  // "y"
	0x44, 0x64, 0x54, 0x4c, 0x44, 0x00,  // "z"
	0x00, 0x08, 0x36, 0x41, 0x00, 0x00,  // "{"
	0x00, 0x00, 0x77, 0x00, 0x00, 0x00,  // "|"
	0x00, 0x41, 0x36, 0x08, 0x00, 0x00,  // "}"
	0x02, 0x01, 0x02, 0x04, 0x02, 0x00,  // "~"
	0x00, 0x06, 0x09, 0x09, 0x06, 0x00,  // degrees symbol
	//96*6 = 576 Bytes
    //Special Characters ** NON-ASCII **
	0x00, 0x00, 0x7f, 0x41, 0x41, 0x41,  // "["
	0x41, 0x41, 0x41, 0x7f, 0x00, 0x00,  // "]"
};

unsigned char lcd128x64Mem[8][128];

/***************************************************************************//**
 * @brief   Sets Address of the LCD RAM memory
 *
 *          (0,0) is the lower left corner of screen.
 * @param   pa Page Address of the LCD RAM memory to be written (0 - 7)
 * @param   ca Column Address of the LCD RAM memory to be written (0 - 127)
 * @return  None
 ******************************************************************************/
void lcd_setAddress(unsigned char row,unsigned char col)
{
	wr_com(0xb7-row);
	wr_com(0x10+(col/16));
	wr_com(0x00+(col%16));
}

/***************************************************************************//**
 * @brief  Draws a pixel at (x,y).
 *
 *          (0,0) is the lower left corner of screen.
 * @param  x x-coordinate of the point
 * @param  y y-coordinate of the point
 * @param   color The color of the pixel
 *                - NORMAL = 1 = dark pixel
 *                - INVERT = 0 = inverts pixel
 * @return None
 ******************************************************************************/
void lcd_pixelDraw(unsigned char x,unsigned char y,unsigned char color)
{
	if(x > 127)
		x = 127;
	
	if(y > 63 )
		y = 63;
	
	if(color){
		lcd128x64Mem[y/8][x] |= 0x80 >> (y%8) ;
	}
	else {
		lcd128x64Mem[y/8][x] &= ~(0x80 >> (y%8)) ;
	}
	lcd_setAddress(y/8,x);
	wr_data(lcd128x64Mem[y/8][x]);
}

/***************************************************************************//**
 * @brief  Draws a line from (x1,y1) to (x2,y2).
 *
 *         Uses Bresenham's line algorithm.
 *         (0,0) is the lower left corner of screen.
 * @param  x1   x-coordinate of the first point
 * @param  y    y-coordinate of the first point
 * @param  x2   x-coordinate of the second point
 * @param  y2   y-coordinate of the second point
 * @param   color The color of the line
 *                - NORMAL = 1 = dark line, overwrites
 *                - INVERT = 0 = inverts color on line
 * @return None
 ******************************************************************************/
void lcd_lineDraw(unsigned char x1, unsigned char y1, unsigned char x2, unsigned char y2, unsigned char color)
{ 
	int8_t x, y, deltay, deltax, d;
    int8_t x_dir, y_dir;

    //make sure we won't be writing off the screen
    if (y1 > 63){
        y1 = 63;
    }
    if (y2 > 63){
        y2 = 63;
    }

    if (x1 > 127){
        x1 = 127;
    }
    if (x2 > 127){
        x2 = 127;
    }

	if (x1 > x2){
		x_dir = -1;
	}
	else{
		x_dir = 1;
	}

	if (y1 > y2){
		y_dir = -1;
	}
	else{
		y_dir = 1;
	}
	
	x = x1;
	y = y1;
	deltay = abs(y2 - y1);
	deltax = abs(x2 - x1);

	if (deltax >= deltay)
	{
		d = (deltay << 1) - deltax;
		while (x != x2)
		{
			lcd_pixelDraw(x, y,  color);
			if (d < 0)
				d += (deltay << 1);
			else
			{
				d += ((deltay - deltax) << 1);
				y += y_dir;
			}
			x += x_dir;
		}
	}
	else
	{
		d = (deltax << 1) - deltay;
		while (y != y2)
		{
			lcd_pixelDraw(x, y, color);
			if (d < 0)
				d += (deltax << 1);
			else
			{
				d += ((deltax - deltay) << 1);
				x += x_dir;
			}
			y += y_dir;
		}
	}
	
}

/***************************************************************************//**
 * @brief   Draw a circle of Radius with center at (x,y).
 *
 *          Uses Bresenham's circle algorithm.
 *          (0,0) is the lower left corner of screen.
 * @param   x   x-coordinate of the circle's center point
 * @param   y   y-coordinate of the circle's center point
 * @param   radius  Radius of the circle
 * @param   color The color of the circle
 *                - NORMAL = 1 = dark line, overwrites
 *                - INVERT = 0 = inverts color on line
 * @return  None
 ******************************************************************************/
void lcd_circleDraw(unsigned char x,unsigned char y,unsigned char radius ,unsigned char color)
{
	int8_t xx, yy, ddF_x, ddF_y, f;

    ddF_x = 0;
    ddF_y = -(2 * radius);
    f = 1 - radius;

    xx = 0;
    yy = radius;
	
	lcd_pixelDraw(x + xx, y + yy, color);
    lcd_pixelDraw(x + xx, y - yy, color);
    lcd_pixelDraw(x - xx, y + yy, color);
    lcd_pixelDraw(x - xx, y - yy, color);
    lcd_pixelDraw(x + yy, y + xx, color);
    lcd_pixelDraw(x + yy, y - xx, color);
    lcd_pixelDraw(x - yy, y + xx, color);
    lcd_pixelDraw(x - yy, y - xx, color);
	
	 while (xx < yy){
        if (f >= 0){
            yy--;
            ddF_y += 2;
            f += ddF_y;
        }
        xx++;
        ddF_x += 2;
        f += ddF_x + 1;
        lcd_pixelDraw(x + xx, y + yy, color);
        lcd_pixelDraw(x + xx, y - yy, color);
        lcd_pixelDraw(x - xx, y + yy, color);
        lcd_pixelDraw(x - xx, y - yy, color);
        lcd_pixelDraw(x + yy, y + xx, color);
        lcd_pixelDraw(x + yy, y - xx, color);
        lcd_pixelDraw(x - yy, y + xx, color);
        lcd_pixelDraw(x - yy, y - xx, color);
    }
}
//***************send_data********************************
void data_send(unsigned char dat)
{
	unsigned char s,temp;
	int i;
	CLR_SCL();
	s=dat;
	for(i=8;i>0;i--)
	{
		CLR_SCL();
		nop();
		nop();
		temp=s&0x80;

		if(temp)
		{
			SET_DI();
		}
		else
		{
			CLR_DI();
		}

		SET_SCL();
		s=s<<1;
	}
}
//***************write command*****************************
void wr_com(unsigned char com)
{
   CLR_A0();
   CLR_CS();
   data_send(com);
   SET_CS();
}

//***************write data********************************
void wr_data(unsigned char dat)
{
   SET_A0();
   CLR_CS();
   data_send(dat);
   SET_CS();
}

 //************lcd initial***********************************
void LcdInit()
{
	CLR_RST();
	delay_1ms(10);				 //delay 10ms
	SET_RST();
	delay_1ms(10);
	wr_com(0xa0);    //ADC normal
	wr_com(0xc8);    //com normal
	wr_com(0xa2);    //set partial display duty 1/65
	wr_com(0x2c);    //vc on
	delay_1ms(100);
	wr_com(0x2e);    //vr on
	delay_1ms(100);
	wr_com(0x2f);    //internal booster,follower,divided on
	wr_com(0x24);    //set rb/ra=5.29
	wr_com(0x81);    //set reference voltage select
	wr_com(0x1d);
	delay_1ms(100);
	wr_com(0xaf);
	wr_com(0x40);    //set start line 00

    display_lattice(0x00, 0x00);
}

//**********display_rect**************************************
void display_rect()
{
   unsigned char seg;
   unsigned char page;

   for(page=0xb0;page<0xb8;page++)
   {
	   if(page==0xb0)
	   {
		   wr_com(page);
		   wr_com(0x10);
		   wr_com(0x00);

		   for(seg=0;seg<128;seg++)
		   {
			   if(seg==0)   wr_data(0xff);
			   else if(seg==127) wr_data(0xff);
			   else              wr_data(0x01);
		   }
	   }
	   else
	   {
		   if(page==0xb7)
		   {
			   wr_com(page);
		       wr_com(0x10);
	           wr_com(0x00);
	           for(seg=0;seg<128;seg++)
		       {
	        	   if(seg==0)   wr_data(0xff);
	        	   else if(seg==127) wr_data(0xff);
	        	   else              wr_data(0x80);
		       }
		   }
		   else
		   {
			   wr_com(page);
		       wr_com(0x10);
	           wr_com(0x00);

	           for(seg=0;seg<128;seg++)
		       {
	        	   if(seg==0)   wr_data(0xff);
		           else if(seg==127) wr_data(0xff);
		       	   else              wr_data(0x00);
		       }
			}
		}
	}
}

//********display_lattice**********************************
void display_lattice(unsigned char dat1,unsigned char dat2)
{
   unsigned char seg;
   unsigned char page;
   for(page=0xb0;page<0xb8;page++)
	{
		wr_com(page);
		wr_com(0x10);
		wr_com(0x00);
		for(seg=0;seg<64;seg++)
		{
			wr_data(dat1);
			wr_data(dat2);
		}
	}
 }

void LcdClear()
{
   unsigned char seg;
   unsigned char page;
   for(page=0xb0;page<0xb8;page++)
   {
		 wr_com(page);
		 wr_com(0x10);
		 wr_com(0x00);
		 for(seg=0;seg<128;seg++)
		 {
			 wr_data(0x00);
		 }
   }
}

//******display_map*****************************************
void display_map(unsigned char* p)
{
   unsigned char seg;
   unsigned char page;
   for(page=0xb0;page<0xb8;page++)
	{
		wr_com(page);
		wr_com(0x10);
		wr_com(0x00);
		for(seg=0;seg<128;seg++)
		{
			wr_data(*p);
			++p;
		}
	}
}

//**************display a character***********************************
void disp_word(uchar row,uchar col,uchar ascii)    //col 0-15, row 0-3
{
	uint i;
  	uint X=(ascii-0x20)*0x06;
	wr_com(0xb7-row);
	wr_com(0x10+(6*col/16));
	wr_com(0x00+(6*col%16));
	
	for(i=0; i < 6; ++i){
		wr_data(FONT6x8[X++]);
	}
	
	col=col+1;
}

////*************display Chinese word****************
void disp_chn(uchar row, uchar col, uchar cn)
{
	uint i;
	uint X=cn*32;
	wr_com(0xb7-row-1);
	wr_com(0x10+(8*col/16));
	wr_com(0x00+(8*col%16));
	for(i=0;i<16;i++) wr_data(tab[X++]);
	wr_com(0xb7-row);
	wr_com(0x10+(8*col/16));
	wr_com(0x00+(8*col%16));
	for(i=0;i<16;i++) wr_data(tab[X++]);
	wr_com(0xb7-row);
	col=col+2;
}

//***************display a string**********************
void disp_str(uchar row,uchar col,uchar *cn)
{
   while(*cn!=0)
   {
	   if(col==16)
	   {
		   row+=2;
		   col=0;
	   }
	   if(row==8)
	   {
		   row=0;
	   }
	   disp_word(row, col, ' ');
	   disp_word(row, col, *cn++);
	   col+=1;
   }
}

// Dsplay a Byte
void DisplayByteInHex(unsigned char value, uchar row, uchar col)
{
	uchar iCnt;
	int   valuetemp;
	uchar temp;

	valuetemp = value;
	disp_word(row, col, '0');
	disp_word(row, (col+1), 'x');

	for(iCnt = 2; iCnt > 0; --iCnt){
		temp = valuetemp & 0x000f;
		if(temp > 9){
			temp = temp + 48 + 7; //A - F
		}
		else{
			temp = temp + 48;  //0 - 9
		}
		disp_word(row, (col+iCnt+1), ' ');
		disp_word(row, (col+iCnt+1), temp);
		valuetemp >>= 4;
	}
}

// Dsplay a int
int DisplayIntInHex(unsigned int value, uchar row, uchar col)
{
	uchar iCnt;
	int   valuetemp;
	uchar temp;

	valuetemp = value;
	disp_word(row, col, '0');
	disp_word(row, (col+1), 'x');

	for(iCnt = 4; iCnt > 0; --iCnt){
		temp = valuetemp & 0x000f;
		if(temp > 9){
			temp = temp + 48 + 7; //A - F
		}
		else{
			temp = temp + 48;  //0 - 9
		}
		disp_word(row, (col+iCnt+1), ' ');
		disp_word(row, (col+iCnt+1), temp);
		valuetemp >>= 4;
	}
	
	return 6;
}

// 显示一个整数，最多可以显示10位整数(小于4294967295)
// value - 需要显示的数据，最大是一个10位数 n - 如果value=0，那相当于显示精度 row - 行  col - 列
int DisplayULongInDec(unsigned long value, unsigned char row, unsigned char col)
{
	int i, m;
	unsigned long temp1 = 0;
	unsigned long temp2 = 0;
	
	m = 1;
	temp1 = value;

	// 确定位数
	while(temp1 >= 10){
		++m;
		temp1 = temp1 / 10;
	}
	
	// 显示
	temp1 = value;
	for(i=m; i > 0; --i){
		disp_word(row, (col + m - i), ' ');
		disp_word(row, (col + m - i), (unsigned char)(temp1/(pow(10, i-1)) + 48));
		temp2 = floor(temp1 / (pow(10, i-1))) * (pow(10, i-1));
		temp1 -= temp2;
	}
	
	return m;
}

// 显示一个5位浮点数，超过范围则不显示
// value - 需要显示的数据  n - 显示的小数位,取值范围为0-5  row - 行  col - 列
int DisplayDoubleInDec(double value, int n, unsigned char row, unsigned char col)
{
	int i, iRet;
	int temp = 0;
	int temp1 = 0;
	int temp2 = 0;
	
	//输出整数部分
	temp = floor(value);
	iRet = DisplayULongInDec(temp, row, col);   // 如果是0，只显示一位0
	if(iRet < 1 || iRet > 5){
		return 0;
	}
	
	// 输出小数点
	disp_word(row, (col + iRet), ' ');
	disp_word(row, (col + iRet), '.');
	
	// 输出小数部分
	//temp = ceil(value * pow(10, n)) - floor(value) * pow(10, n);
	//DisplayULongInDec(temp, n, row, (col + iRet + 1));
    //当小数部分最高位是0，用显示整数的逻辑显示小数是有问题的	
	temp1 = ceil(value * pow(10, n)) - floor(value) * pow(10, n);
	for(i=n; i > 0; --i){
		disp_word(row, (col + iRet + n - i + 1), ' ');
		disp_word(row, (col + iRet + n - i + 1), (unsigned char)(temp1/(pow(10, i-1)) + 48));
		temp2 = floor(temp1 / (pow(10, i-1))) * (pow(10, i-1));
		temp1 -= temp2;
	}
	
	//返回占用了多少显示位置
	iRet += (n+1);
	return iRet;
}
