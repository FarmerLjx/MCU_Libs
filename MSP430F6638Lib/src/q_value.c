/* 
* @FileName: q_value.c
* @Author  : PeeNut
* @Date    : 2015-08-08 19:48:15
* @Description: 制作Q表的时候写的，主要提供的是一个查找表的函数
*               二分法实现，查找表和目标最接近的两个数字
* @Modified by  |  Modified time  |  Description 
*  
*/

#include "../inc/q_value.h"

// 电容查找表 -- 电容值: 10 * 12 + 4
float CTableC[C_TABLE_NUM] = {
	303.000, 302.000, 299.700, 296.100, 293.900, 291.900, 289.700, 287.700, 285.200, 283.100, /*10*/
	281.100, 279.000, 278.300, 276.500, 273.900, 272.200, 270.600, 268.400, 267.500, 265.600, /*20*/
	263.400, 261.100, 260.100, 259.900, 258.200, 256.900, 254.000, 251.100, 249.900, 246.500, /*30*/
	238.800, 235.700, 235.200, 231.800, 230.500, 228.300, 226.700, 222.700, 221.500, 219.800, /*40*/
	216.900, 211.400, 210.500, 208.300, 205.700, 201.300, 196.600, 187.700, 183.600, 179.500, /*50*/
	176.500, 173.300, 171.600, 169.700, 164.500, 163.400, 160.500, 156.000, 156.100, 153.400, /*60*/
	149.300, 147.100, 145.900, 142.300, 140.500, 138.700, 134.600, 133.700, 131.300, 128.900, /*70*/
	125.300, 122.700, 120.200, 116.400, 115.700, 112.100, 108.800, 106.700, 102.300, 99.970,  /*80*/
	97.630, 96.040, 95.140, 91.760, 89.240, 87.370, 85.340, 82.090, 81.050, 79.480, /*90*/
	75.790, 74.410, 71.170, 67.960, 64.040, 61.460, 58.870, 57.200, 55.160, 53.480, /*100*/
	50.930, 48.370, 45.490, 42.110, 40.490, 37.850, 34.480, 31.250, 27.490, 25.750, /*110*/
	23.710, 22.400, 20.620, 18.640, 17.940, 16.140, 15.020, 13.330, 12.030, 11.130, /*120*/
	9.899, 8.203, 7.495, 7.166 /*124*/
};

// 电容查找表 -- 电压比值
float CTableVRate[C_TABLE_NUM] = {
	1.367, 1.381, 1.391, 1.401, 1.410, 1.415, 1.419, 1.424, 1.431, 1.436,   /*10*/
	1.445, 1.450, 1.452, 1.462, 1.470, 1.474, 1.479, 1.482, 1.488, 1.494,   /*20*/
	1.502, 1.505, 1.510, 1.513, 1.519, 1.522, 1.534, 1.544, 1.542, 1.551,   /*30*/
	1.576, 1.586, 1.592, 1.597, 1.608, 1.617, 1.619, 1.635, 1.642, 1.641,   /*40*/
	1.662, 1.677, 1.689, 1.692, 1.706, 1.725, 1.742, 1.776, 1.802, 1.815,   /*50*/
	1.834, 1.845, 1.858, 1.866, 1.893, 1.895, 1.911, 1.935, 1.940, 1.950,   /*60*/
	1.979, 1.985, 1.995, 2.019, 2.034, 2.038, 2.060, 2.073, 2.087, 2.105,   /*70*/
	2.138, 2.145, 2.166, 2.199, 2.204, 2.237, 2.261, 2.281, 2.325, 2.350,   /*80*/
	2.376, 2.390, 2.403, 2.439, 2.483, 2.503, 2.541, 2.583, 2.601, 2.643,   /*90*/
	2.703, 2.742, 2.802, 2.863, 2.963, 3.042, 3.109, 3.162, 3.224, 3.291,   /*100*/
	3.390, 3.480, 3.608, 3.784, 3.873, 4.038, 4.256, 4.495, 4.898, 5.147,   /*110*/
	5.512, 5.759, 6.167, 6.792, 7.046, 7.770, 8.325, 9.470, 10.581, 11.567, /*120*/
	13.219, 16.381, 19.105, 21.782 /*124*/
};


// Function List
// 根据电压比值获取电容值
float GetCValueByVRate(float fVRate)
{
	int mid;
	int start = 0;
	int end   = C_TABLE_NUM;
	float fRet;
	
	mid = BinarySearchRecursion(CTableVRate, fVRate, start, end);
	
	// 不在表的范围之内，则使用近似公式计算
	if(-1 == mid){
		fRet = (-2.5949 * fVRate + 313.79);
		if(fRet < 0){
			fRet = 0;
		}
		else if(fRet > 313.79){
			fRet = 313.79;
		}
	}
	// 如果在表内，则使用
	else{
		fRet = (CTableC[mid] + CTableC[mid + 1]) / 2;
	}

	return fRet;
}

// 二分法查找中间两位和目标最接近的索引，返回较小的一个，mid，表示目标value满足：
// arry[mid] <= value < arry[mid+1]
int BinarySearchRecursion(float arry[], float value, int start,int end)
{
    if(start > end){
		return -1;
	}
	if(value < 1.367 || value > 21.782){
		return -1;
	}
	
    int mid = start + (end - start) / 2;
	// 只能说是近似值，所以这里的判断条件需要注意
	// 在mid和mid+1之间，返回mid
    if(value >= arry[mid] && value <= arry[mid+1])
        return mid;
	// 如果小于mid，end设置为mid (如果设置为mid-1会出现遗漏，导致出错)
    else if(value < arry[mid])
    {
        end = mid;
        return BinarySearchRecursion(arry, value, start, end);
    }
	// 如果大于mid+1,设置start为mid+1 (如果设置为mid+2，也会有遗漏，导致出错)
    else //  if(value > arry[mid+1])
    {
        start = mid + 1;
        return BinarySearchRecursion(arry, value, start, end);
    }
}
